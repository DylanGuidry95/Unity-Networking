#pragma warning disable 0168
#pragma warning disable 0219
#pragma warning disable 0414

using UnityEngine;

using UnityEngine.Networking;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine.Events;
using UnityEngine.UI;


/*
SyncEvents allow networked actions to be propagated to other scripts attached to the object. In the example above, the Other class registers for the TakeDamage event on the DamageClass. When the event happens on the DamageClass on the server, the TakeDamage() method will be invoked on the Other class on the client object. This allows modular network aware systems to be created, that can be extended by new scripts that respond to the events generated by them.
*/

public class GameManager : NetworkBehaviour
{
    public delegate void EventPlayerChange();

    [SyncEvent]
    public static event EventPlayerChange EventOnPlayerChange;

    [ClientRpc]
    public void RpcPlayerChange()
    {
        Debug.Log("PlayerChange Event!");
        if (EventOnPlayerChange != null)
            EventOnPlayerChange();
    }

    [SyncVar]
    public int numCards;

    static public GameManager singleton;
    static public List<PlayerManager> m_Players = new List<PlayerManager>();

    public List<Player> Players = new List<Player>();
    public bool quit = false;
    private WaitForSeconds m_Wait;
    public GameObject m_PlayerPrefab;

    [SerializeField]
    private GameObject m_UI;
    private UIServer m_UIServer;

    [SyncVar]
    private int m_activePlayerIndex;

    [SyncVar]
    public bool hasStarted = false;

    [SerializeField]
    public Player activePlayer;

    [SerializeField]
    private TreasureStack m_TreasureStack;

    private PlayerManager m_activePlayerManager;

    public PlayerManager activePlayerManager
    {
        get
        {
            return m_activePlayerManager;
        }
        set
        {
            m_activePlayerManager = value;
            activePlayer = m_activePlayerManager.Player;
            m_activePlayerManager.SetReady();
            RpcUpdateUI(activePlayer.name, m_TreasureStack.NumCards);

        }
    }

    #region Setup
    public static void AddPlayer(GameObject player, int playerNum, Color c, string name, int localID)
    {
        PlayerManager pm = new PlayerManager();
        pm.Setup(player, playerNum, c, name, localID);
        m_Players.Add(pm);
    }


    public void RemovePlayer(GameObject p)
    {
        PlayerManager toRemove = null;
        foreach (var tmp in m_Players)
        {
            if (tmp.Instance == p)
            {
                toRemove = tmp;
                break;
            }
        }

        if (toRemove != null)
            m_Players.Remove(toRemove);
    }
    #endregion Setup


    void Awake()
    {
        singleton = this;

        m_UIServer = m_UI.GetComponent<UIServer>();
        m_TreasureStack = GetComponent<TreasureStack>();
        m_Wait = new WaitForSeconds(1);
    }

    [ServerCallback]
    void Start()
    {
        foreach (PlayerManager pm in m_Players)
            Players.Add(pm.Player);

        m_TreasureStack.Setup();
        m_activePlayerIndex = 0;
        activePlayerManager = m_Players[m_activePlayerIndex];
        RpcUpdateUI(activePlayer.name, m_TreasureStack.NumCards);
        StartCoroutine(GameLoop());
    }

    IEnumerator GameLoop()
    {
        RpcUpdateUI(activePlayer.name, m_TreasureStack.NumCards);
        RpcMessage("Player Count: " + m_Players.Count);
        //wait to be sure that all are ready to start
        yield return new WaitForSeconds(2.0f);
        yield return StartCoroutine(GameStart());
        yield return StartCoroutine(PlayerTurn());
        yield return StartCoroutine(GameRunning());
    }    
        
    [ClientRpc]
    void RpcUpdateUI(string n, int c)
    {
        FindObjectOfType<UIServer>().ActivePlayer.text = "PlayerName: " + n;
        FindObjectOfType<UIServer>().CardCount.text = "TreasureStack: " + c.ToString();
    }

    [ClientRpc]
    void RpcMessage(string message)
    {
        Debug.Log(message);
    }



    IEnumerator GameStart()
    {
        print("GameStart()");

        RpcGameStart();
        hasStarted = true;
        yield return null;
    }

    [ClientRpc]
    private void RpcGameStart()
    {
        EnableControls();
        m_TreasureStack.SpawnCards();
    }

    IEnumerator PlayerTurn()
    {

        RpcMessage("Begin Player Turn");
        activePlayerManager.SetReady();
        while (activePlayerManager.IsTakingTurn)
        {
            yield return null;
        }

        m_activePlayerIndex += 1;
        if (m_activePlayerIndex >= m_Players.Count)
            m_activePlayerIndex = 0;

        activePlayerManager = m_Players[m_activePlayerIndex];


        yield return null;
        yield return StartCoroutine(PlayerTurn());
    }
    IEnumerator GameRunning()
    {
        Debug.Log("Game Running...");
        while (m_Players.Count > 1)
        {
            yield return new WaitForSeconds(1);
            yield return null;
        }
        print("Shutting down server");
        Application.Quit();
    }


    private void EnableControls()
    {
        for (int i = 0; i < m_Players.Count; ++i)
        {
            m_Players[i].EnableControl();
        }
    }

    private void DisableControls()
    {
        for (int i = 0; i < m_Players.Count; ++i)
        {
            m_Players[i].DisableControl();
        }
    }

    void SetCouchCams()
    {

        Rect Left = new Rect(0, 0, 1, .5f);
        Rect Right = new Rect(0, 0.5f, 1, .5f);
        m_Players[0].PlayerCamera.rect = Left;
        m_Players[1].PlayerCamera.rect = Right;
    }

}


