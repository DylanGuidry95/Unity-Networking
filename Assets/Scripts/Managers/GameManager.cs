#pragma warning disable 0168
#pragma warning disable 0219
#pragma warning disable 0414

using UnityEngine;

using UnityEngine.Networking;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine.Events;
using UnityEngine.UI;


/*
SyncEvents allow networked actions to be propagated to other scripts attached to the object. In the example above, the Other class registers for the TakeDamage event on the DamageClass. When the event happens on the DamageClass on the server, the TakeDamage() method will be invoked on the Other class on the client object. This allows modular network aware systems to be created, that can be extended by new scripts that respond to the events generated by them.
*/

public class GameManager : NetworkBehaviour
{
    public delegate void PlayerChangeDelegate(string name, string count);
    [SyncEvent]
    public event PlayerChangeDelegate EventPlayerChange;
    [Command]
    public void CmdDoMe(string n, string c)
    {
        EventPlayerChange(n, c);
    }

    public static GameManager singleton = null;
    public static List<PlayerManager> m_Players = new List<PlayerManager>();
    public List<Player> Players = new List<Player>();
    public bool quit = false;
    private WaitForSeconds m_Wait;
    public GameObject m_PlayerPrefab;
    [SyncVar]
    private int activePlayerIndex;

    [SyncVar]
    public bool hasStarted = false;

    [SerializeField]
    public Player activePlayer;

    private PlayerManager m_activePlayerManager;

    public PlayerManager activePlayerManager
    {
        get
        {
            return m_activePlayerManager;
        }
        set
        {
            m_activePlayerManager = value;
            activePlayer = m_activePlayerManager.Player;
            m_activePlayerManager.SetReady();
            if(!isClient)
                EventPlayerChange(activePlayer.PlayerName, GetComponent<TreasureStack>().NumCards.ToString());
        }
    }

    public void AddPlayer(GameObject player, string name)
    {
        PlayerManager pm = new PlayerManager();
        pm.Setup(player, name);
        m_Players.Add(pm);
        
        Debug.Log("add player " + pm.PlayerName);
    }

    public void RemovePlayer(GameObject p)
    {
        PlayerManager toRemove = null;
        foreach (var tmp in m_Players)
        {
            if (tmp.Instance == p)
            {
                toRemove = tmp;
                break;
            }
        }

        if (toRemove != null)
            m_Players.Remove(toRemove);
    }

    private void UpdateUI(string n, string c)
    {
        Debug.Log("update client with " + n + ":" + c);
        UIServer.singleton.UpdateUIServer(n, c);
    }

    private void Awake()
    {
        singleton = this;
    }




    
    private void Start()
    {
        m_Wait = new WaitForSeconds(1);
        foreach (PlayerManager pm in m_Players)
            Players.Add(pm.Player);
        StartCoroutine(GameLoop());

    }

    [SerializeField]
    private bool ggAllIn;
    IEnumerator GameLoop()
    {
        while (m_Players.Count < 2)
        {
            Debug.Log("Player Count: " + m_Players.Count);     
            yield return null;
        }
        bool allready = true;
        while (!allready)
        {
            
            foreach (PlayerManager pm in m_Players)
            {
                Debug.Log(pm.IsReady());
                allready &= pm.IsReady();
            }
            ggAllIn = allready;
            Debug.Log(ggAllIn);
            yield return null;
        }

        //wait to be sure that all are ready to start
        yield return new WaitForSeconds(2.0f);
        yield return StartCoroutine(GameStart());
        yield return StartCoroutine(PlayerTurn());
        yield return StartCoroutine(GameRunning());
    }

    public bool StackReady = false;
    IEnumerator GameStart()
    {
        print("GameStart()");
        float t = Time.time;
        float dt = 0;
        activePlayerIndex = 0;
        activePlayerManager = m_Players[activePlayerIndex];
        //while (!StackReady)
        //{
        //    dt += Time.deltaTime;

        //    if (dt > 1) dt = 0;

        //    Debug.Log("waiting for stack to ready");
        //    yield return null;

        //}

        hasStarted = true;
        yield return null;
    }

    void SetCouchCams()
    {

        //    Rect Left = new Rect(0, 0, 1, .5f);
        //    Rect Right = new Rect(0, 0.5f, 1, .5f);
        //    m_Players[0].PlayerCamera.rect = Left;
        //    m_Players[1].PlayerCamera.rect = Right;
    }

    IEnumerator PlayerTurn()
    {
        print("begin PlayerTurn");
        activePlayerManager.SetReady();
        while (activePlayerManager.IsTakingTurn)
        {
            yield return null;
        }

        activePlayerIndex += 1;
        if (activePlayerIndex >= m_Players.Count)
            activePlayerIndex = 0;

        activePlayerManager = m_Players[activePlayerIndex];
        yield return null;
        yield return StartCoroutine(PlayerTurn());
    }

    IEnumerator GameRunning()
    {
        while (m_Players.Count > 1)
        {            
            yield return null;
        }
        print("Shutting down server");
        yield return new WaitForSeconds(2);
        Prototype.NetworkLobby.LobbyManager.s_Singleton.ServerReturnToLobby();
    }
}


